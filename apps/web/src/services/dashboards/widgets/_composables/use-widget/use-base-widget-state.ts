import type { ComputedRef, Ref, UnwrapRef } from 'vue';
import {
    computed, reactive, toRef, toRefs,
} from 'vue';

import { CURRENCY } from '@/store/modules/settings/config';
import type { Currency } from '@/store/modules/settings/type';

import type { MergedBaseWidgetState } from '@/services/dashboards/widgets/_composables/use-widget/merge-base-widget-state';
import {
    mergeBaseWidgetState,
} from '@/services/dashboards/widgets/_composables/use-widget/merge-base-widget-state';
import type {
    WidgetProps,
    CostDataField,
    AssetDataField,
    Granularity,
} from '@/services/dashboards/widgets/_configs/config';
import type { ChartType } from '@/services/dashboards/widgets/type';

/**
 * @description It returns states which is among the data generated by widget info and widget config through combination,
 * it's expected to be applicable universally across all widgets,
 * rather than being specifications that need to be defined or implemented differently for each widget.
 */
export interface BaseWidgetState extends MergedBaseWidgetState {
    granularity: ComputedRef<Granularity|undefined>;
    chartType: ComputedRef<ChartType|undefined>;
    dataField: ComputedRef<CostDataField|AssetDataField|undefined>;
    secondaryDataField: ComputedRef<CostDataField|AssetDataField|undefined>;
    parsedDataField: ComputedRef<string>; // remove dots from dataField e.g. additional_info.Usage Type Details -> Usage Type Details
    parsedSecondaryDataField: ComputedRef<string>; // remove dots from secondaryDataField
    currency: Ref<Currency|undefined>;
}

export function useBaseWidgetState(props: WidgetProps): UnwrapRef<BaseWidgetState> {
    const mergedState = mergeBaseWidgetState({
        inheritOptions: toRef(props, 'inheritOptions'),
        widgetOptions: toRef(props, 'options'),
        widgetName: toRef(props, 'widgetConfigId'),
        dashboardSettings: toRef(props, 'dashboardSettings'),
        dashboardVariablesSchema: toRef(props, 'dashboardVariablesSchema'),
        dashboardVariables: toRef(props, 'dashboardVariables'),
        title: toRef(props, 'title'),
        schemaProperties: toRef(props, 'schemaProperties'),
    });

    const state = reactive<BaseWidgetState>({
        ...toRefs(mergedState) as MergedBaseWidgetState,
        granularity: computed(() => mergedState.options?.granularity),
        chartType: computed<ChartType|undefined>(() => mergedState.options?.chart_type),
        dataField: computed(() => {
            if (mergedState.widgetConfig.labels?.includes('Cost')) return mergedState.options?.cost_data_field;
            if (mergedState.widgetConfig.labels?.includes('Asset')) return mergedState.options?.asset_data_field;
            return undefined;
        }),
        secondaryDataField: computed(() => {
            if (mergedState.widgetConfig.labels?.includes('Cost')) return mergedState.options?.cost_secondary_data_field;
            if (mergedState.widgetConfig.labels?.includes('Asset')) return mergedState.options?.asset_secondary_data_field;
            return undefined;
        }),
        parsedDataField: computed<string>(() => parseDotFromDataField(state.dataField)),
        parsedSecondaryDataField: computed<string>(() => parseDotFromDataField(state.secondaryDataField)),
        currency: computed<Currency|undefined>(() => {
            const dataSources = props.allReferenceTypeInfo.cost_data_source.referenceMap;
            if (mergedState.widgetConfig.labels?.includes('Cost')) {
                if (!mergedState.options?.cost_data_source) return CURRENCY.USD;
                return dataSources[mergedState.options.cost_data_source]?.data?.plugin_info?.metadata?.currency;
            }
            return undefined;
        }),

    }) as UnwrapRef<BaseWidgetState>;

    return state;
}


const parseDotFromDataField = (dataField: string|undefined) => {
    if (!dataField) return '';
    const split = dataField.split('.');
    return split.length > 0 ? (split.pop() ?? '') : (dataField ?? '');
};
