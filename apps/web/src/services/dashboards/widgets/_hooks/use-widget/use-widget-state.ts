import type { ComputedRef, Ref, UnwrapRef } from 'vue';
import {
    computed, reactive, toRef, toRefs,
} from 'vue';
import type { Location } from 'vue-router/types/router';

import dayjs from 'dayjs';
import { flattenDeep, isEmpty } from 'lodash';

import { QueryHelper } from '@cloudforet/core-lib/query';
import type { ConsoleFilter } from '@cloudforet/core-lib/query/type';

import { CURRENCY } from '@/store/modules/settings/config';
import type { Currency } from '@/store/modules/settings/type';

import { REFERENCE_TYPE_INFO } from '@/lib/reference/reference-config';
import { arrayToQueryString, objectToQueryString, primitiveToQueryString } from '@/lib/router-query-string';

import { ASSET_INVENTORY_ROUTE } from '@/services/asset-inventory/route-config';
import { DYNAMIC_COST_QUERY_SET_PARAMS } from '@/services/cost-explorer/cost-analysis/config';
import { COST_EXPLORER_ROUTE } from '@/services/cost-explorer/route-config';
import type { DateRange } from '@/services/dashboards/config';
import type {
    WidgetProps,
    WidgetFiltersMap,
    CostDataField,
    AssetDataField,
    Granularity,
} from '@/services/dashboards/widgets/_configs/config';
import {
    GRANULARITY,
} from '@/services/dashboards/widgets/_configs/config';
import { getWidgetLocationFilters } from '@/services/dashboards/widgets/_helpers/widget-location-helper';
import type { MergedWidgetState } from '@/services/dashboards/widgets/_hooks/use-widget/use-merged-widget-state';
import {
    useMergedWidgetState,
} from '@/services/dashboards/widgets/_hooks/use-widget/use-merged-widget-state';
import type { ChartType } from '@/services/dashboards/widgets/type';

/**
 * @description It returns states which is among the data generated by widget info and widget config through combination,
 * it's expected to be applicable universally across all widgets,
 * rather than being specifications that need to be defined or implemented differently for each widget.
 */
export interface WidgetState extends MergedWidgetState {
    granularity: ComputedRef<Granularity|undefined>;
    chartType: ComputedRef<ChartType|undefined>;
    dataField: ComputedRef<CostDataField|AssetDataField|undefined>;
    secondaryDataField: ComputedRef<CostDataField|AssetDataField|undefined>;
    parsedDataField: ComputedRef<string>; // remove dots from dataField e.g. additional_info.Usage Type Details -> Usage Type Details
    parsedSecondaryDataField: ComputedRef<string>; // remove dots from secondaryDataField
    dateRange: ComputedRef<DateRange>;
    currency: Ref<Currency|undefined>;
    widgetLocation: ComputedRef<Location|undefined>; // widget location for link which is differentiated by widget labels(e.g. Cost, Asset)
    consoleFilters: ComputedRef<ConsoleFilter[]>;
}
const queryHelper = new QueryHelper();
export function useWidgetState(props: WidgetProps) {
    const baseState = useMergedWidgetState({
        inheritOptions: toRef(props, 'inheritOptions'),
        widgetOptions: toRef(props, 'options'),
        widgetName: toRef(props, 'widgetConfigId'),
        dashboardSettings: toRef(props, 'dashboardSettings'),
        dashboardVariablesSchema: toRef(props, 'dashboardVariablesSchema'),
        dashboardVariables: toRef(props, 'dashboardVariables'),
        title: toRef(props, 'title'),
        schemaProperties: toRef(props, 'schemaProperties'),
    });

    const budgetQueryHelper = new QueryHelper();
    const localState = reactive({
        // locations
        assetWidgetLocation: computed<Location|undefined>(() => {
            const assetQuerySetId = baseState.options.asset_query_set;
            if (!assetQuerySetId) return undefined;
            const assetQuerySet = props.allReferenceTypeInfo.assetQuerySet.referenceMap[assetQuerySetId];
            const consoleFilters = flattenDeep(Object.values(baseState.options.filters ?? {}));
            return {
                name: ASSET_INVENTORY_ROUTE.CLOUD_SERVICE.DETAIL._NAME,
                params: {
                    provider: assetQuerySet.data?.provider,
                    group: assetQuerySet.data?.cloud_service_group,
                    name: assetQuerySet.data?.cloud_service_type,
                },
                query: {
                    filters: queryHelper.setFilters(consoleFilters).rawQueryStrings,
                },
            };
        }),
        budgetWidgetLocation: computed<Location|undefined>(() => {
            const dataSourceId = baseState.options.cost_data_source;
            if (dataSourceId) budgetQueryHelper.setFilters([{ k: 'data_source_id', v: [dataSourceId], o: '=' }]);
            return {
                name: COST_EXPLORER_ROUTE.BUDGET._NAME,
                params: {},
                query: {
                    filters: budgetQueryHelper.rawQueryStrings,
                },
            };
        }),
        costWidgetLocation: computed<Location|undefined>(() => {
            const dataField: string[] = [];
            if (state.dataField) dataField.push(state.dataField);
            if (state.secondaryDataField) dataField.push(state.secondaryDataField);
            const location: Location = {
                name: COST_EXPLORER_ROUTE.COST_ANALYSIS.QUERY_SET._NAME,
                params: {
                    dataSourceId: baseState.options.cost_data_source ?? '',
                    costQuerySetId: DYNAMIC_COST_QUERY_SET_PARAMS,
                },
                query: {
                    granularity: primitiveToQueryString(state.granularity),
                    group_by: arrayToQueryString(dataField),
                    period: objectToQueryString(state.dateRange),
                    filters: arrayToQueryString(getWidgetLocationFilters(baseState.options.filters)),
                },
            };
            return location;
        }),
        // filters
        budgetConsoleFilters: computed<ConsoleFilter[]>(() => {
            if (!baseState.options?.filters || isEmpty(baseState.options.filters)) return [];
            return getConvertedBudgetConsoleFilters(baseState.options.filters);
        }),
        cloudServiceAnalyzeConsoleFilters: computed<ConsoleFilter[]>(() => {
            // set filters from asset query set
            const assetQuerySetId = baseState.options.asset_query_set;
            if (assetQuerySetId) {
                const assetQuerySet = props.allReferenceTypeInfo.assetQuerySet.referenceMap[assetQuerySetId];
                queryHelper.setFilters([
                    { k: 'provider', v: assetQuerySet.data?.provider, o: '=' },
                    { k: 'cloud_service_group', v: assetQuerySet.data?.cloud_service_group, o: '=' },
                    { k: 'cloud_service_type', v: assetQuerySet.data?.cloud_service_type, o: '=' },
                ]);
            }
            return [
                ...flattenDeep(Object.values(baseState.options.filters ?? {})),
                ...queryHelper.filters,
            ];
        }),
    });

    const state = reactive<WidgetState>({
        ...toRefs(baseState) as MergedWidgetState,
        granularity: computed(() => baseState.options?.granularity),
        chartType: computed<ChartType|undefined>(() => baseState.options?.chart_type),
        dataField: computed(() => {
            if (baseState.widgetConfig.labels?.includes('Cost')) return baseState.options?.cost_data_field;
            if (baseState.widgetConfig.labels?.includes('Asset')) return baseState.options?.asset_data_field;
            return undefined;
        }),
        secondaryDataField: computed(() => {
            if (baseState.widgetConfig.labels?.includes('Cost')) return baseState.options?.cost_secondary_data_field;
            if (baseState.widgetConfig.labels?.includes('Asset')) return baseState.options?.asset_secondary_data_field;
            return undefined;
        }),
        parsedDataField: computed<string>(() => parseDotFromDataField(state.dataField)),
        parsedSecondaryDataField: computed<string>(() => parseDotFromDataField(state.secondaryDataField)),
        dateRange: computed<DateRange>(() => {
            const dateRangeFormat = baseState.options.granularity === GRANULARITY.YEARLY ? 'YYYY' : 'YYYY-MM';
            const end = dayjs.utc(baseState.settings?.date_range?.end).format(dateRangeFormat);
            const start = dayjs.utc(baseState.settings?.date_range?.start).format(dateRangeFormat);
            return { start, end };
        }),
        widgetLocation: computed<Location|undefined>(() => {
            if (baseState.widgetConfig.labels?.includes('Budget')) return localState.budgetWidgetLocation;
            if (baseState.widgetConfig.labels?.includes('Asset')) return localState.assetWidgetLocation;
            if (baseState.widgetConfig.labels?.includes('Cost')) return localState.costWidgetLocation;
            return undefined;
        }),
        currency: computed<Currency|undefined>(() => {
            const dataSources = props.allReferenceTypeInfo.cost_data_source.referenceMap;
            if (baseState.widgetConfig.labels?.includes('Cost')) {
                if (!baseState.options?.cost_data_source) return CURRENCY.USD;
                return dataSources[baseState.options.cost_data_source]?.data?.plugin_info?.metadata?.currency;
            }
            return undefined;
        }),
        consoleFilters: computed<ConsoleFilter[]>(() => {
            if (baseState.widgetConfig.labels?.includes('Budget')) {
                return localState.budgetConsoleFilters;
            }
            if (baseState.widgetConfig.labels?.includes('Asset') && baseState.options.data_criteria === 'realtime') {
                return localState.cloudServiceAnalyzeConsoleFilters;
            }
            if (!baseState.options?.filters || isEmpty(baseState.options.filters)) return [];
            return flattenDeep<ConsoleFilter[]>(Object.values(baseState.options.filters));
        }),
    }) as UnwrapRef<WidgetState>;

    return state;
}

const getConvertedBudgetConsoleFilters = (widgetFiltersMap: WidgetFiltersMap): ConsoleFilter[] => {
    const results: ConsoleFilter[] = [];
    Object.entries(widgetFiltersMap).forEach(([filterKey, filterItems]) => {
        if (!filterItems?.length) return;
        if ((filterKey === REFERENCE_TYPE_INFO.project.type || filterKey === REFERENCE_TYPE_INFO.project_group.type)) {
            filterItems.forEach((d) => {
                results.push(d);
            });
        } else {
            filterItems.forEach((d) => {
                const value = Array.isArray(d.v) ? d.v : [d.v];
                results.push({
                    k: d.k,
                    v: value,
                    o: d.o,
                });
            });
        }
    });
    return results;
};

const parseDotFromDataField = (dataField: string|undefined) => {
    if (!dataField) return '';
    const split = dataField.split('.');
    return split.length > 0 ? (split.pop() ?? '') : (dataField ?? '');
};
